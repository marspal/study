### 泛型

`概念:` 一种参数化数据类型, 具有一下特点

特点:

- 定义时不明确、使用时必须明确成某种具体数据类型的数据类型
- 编译期间进行数据类型安全检查的数据的类型

特别注意:

- 类型安全检查发生在编译期间
- 泛型是参数化的数据类型，使用时明确化的数据类型就是参数的值

格式:

```Ts
  // class 类名<泛型形参类型> 1. 必须是A-Z任何一个字母 2. 可以是语义化的单词
  class ArrayList<T> {
    array: Array<T>
    add(data: T) {}
  }
```

- 泛型 any 化 T = {}; 表示的 T 默认为对象类型 T = object; 什么对象都能接
- 泛型默认值(unknown)

### Q/A

> object 为什么不能替代类上的泛型?

Object 所有类型的父类、object 对象类型、任意对象; 和 string 有异曲同工之妙

- 编译期间 object 无法进行类型安全检测, 而泛型在编译期间可以进行类型安全检查
  object 只能接受所有的 object 变量, 如 Customer、Student、Dog 类的实例都是对象类型; 都可以传递给 object 类型的方法参数或者属性，如果我们需要只添加 Customer 类的对象、object 就做不到了；只能使用泛型

- object 类型数据无法接受非 object 类型的变量; 只能接受 object 类型的变量；

- object 类型数据获取属性和方法时无自动提示

> 为什么 any 不能替代类上的泛型?

- 编译期间 any 无法进行类型安全检测, 而泛型在编译期间可以进行类型安全检查;
- any 扩大数据类型的属性后没有编译错误导致潜在的错误风险;
- any 类型数据获取属性和方法时无自动提示; 可以获取任意属性 任意方法 不出现任意错误;

### any 类型 使用场景

```ts
// 判断数据类型; 使用any 可以获取任意属性、任意方法
function isCustomer(data: any): data is Customer {
  return Boolean(data && data.custname);
}
```

### example

- 通用的分页类实现

分页类的实现、泛型改写分页类、T extends object 分页类中的使用
