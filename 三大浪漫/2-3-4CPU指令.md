#### CPU指令 - Opcode、寻址模式、浮点数



##### 计算机指令

- 计算机通过指令指挥计算机工作
- CPU被时钟驱动，不断的读取PC指针指向的指令,并增加PC指针，从内存中读取指令并执行。(周而复始)
- 不同的CPU架构使用不同的指令, 目前使用最广泛的是RISC(精简指令集)

##### 机器循环

从PC位置获取指令  -> 分析指令  -> 执行指令  -> PC++ -> 从PC位置获取指令

##### eg：MIPS-32指令示例

1. 000010    00 0000 0000 0000 0000 1000 0010

opcode=2  target=0b1000010000 =520

将PC指针调转到520的位置 

2. 000000      00001  00010  00110    00000     100000

   opcode=0    rs=1    rs=2     rd=6     shift=0      funct=0x20

​        opcode = 2 和 funct=0x20 决定这是要给add操作

​       将寄存器1 和寄存器2的值加起来存到寄存器6

3. 100011       000011    00101    0000  0000 0010      0100

   op=25          rs=3          rt=5      offset=0b10010000=144

   将寄存器5中的值拿出来和offset合并（相加）得到最终读取的地址

   读取最终地址的值、存入寄存器3

4. 助记符 0b000000(add)   0b000008(addi)

#### 寻址模式

1. 寄存器寻址

- 操作符是寄存器,利用n位寻址2^n个寄存器
- eg: add $r10, $r1, $r2

  op  目标寄存器 源寄存器1 源寄存器2 shamt funct

2. 立即寻址

- 操作符中有值
- eg: addi $r1, $zero, 1000
- 数字大小有限制，如是32位就是[-2^15-1, 2^15]
   $zero 特殊寄存器  里面存0 

   OP 目标寄存器  源寄存器1  数字

3. 偏移量寻址

- 根据基地址和偏移量进行寻址，最终的地址是在基地址和偏移量上计算
- eg: lw  $r0, 8($sp)
  $sp 也是一个寄存器，也是一个栈 一个内存中的地址

   OP  $sp(base寄存器)   目标寄存器    偏移量 （$sp + 8 -> $r0）

4. PC相对寻址

- 下一个PC指针的位置依赖当前位置到Label的距离(当前代码行和Label所在的代码行之差)
- eg: beq  $r3, $rq, LABEL; $r3 $rq相同时 调转到LABEL

  OP  比较目标1     比较目标2  相对差

5. 内存读写

- load/store 指令用来从内存中读/写入内存；通常有多个版本的实现
- load类:  lw lb lh
- store类: sw sb sh

6. 数学运算

- 加减乘除等
  - 立即寻址:  addi subi divi  multi等  addi $sp, $p, 4

- 位运算 and/or/xor等

7. 浮点数

- 十进制里0.1 代表1/10 二进制0.1代表1/2 0.01代表1/4
- 因此0.375 在二进制中表示为0.011

8. 双精度-浮点数表示
   -1<sup>sign</sup>(1 + b<sub>51</sub>b<sub>50</sub>...b<sub>0</sub>) X 2<sup>e-1023</sup>

   -1<sup>0</sup>(1.1)<sup>1</sup> = 1.1 = 1.5

9. 比较运算

- 比较运算比较两个值的大小；eg:
  - slt(set if less than)
  - slt $d, $rs, $rt # d=1 如果rs < rt, d = 0 如果rt >= rt

Q: 字符串比较、对象比较和布尔型比较呢？ 

10. 条件调转

- 相对寻址 j LABEL
- 寄存器间接寻址 jr $a0
- 多合一 jal LABEL 1. 将当前PC+4存入$ra寄存器，j LABEL

总结: 浮点数在计算机中以整数形式存在的
